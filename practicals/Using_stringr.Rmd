---
title: "BIOINF3005/7160: Transcriptomics Applications"
subtitle: "Working With Text in R"
date: "4^th^ March, 2020"
output: 
  html_document:
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    results = "hide",
    message = FALSE,
    warning = FALSE,
    fig.align = "center"
    )
```


## Introduction

In our previous work, we introduced:

- The relationship between R and R Studio
- The advantages of R Markdown
- How to create an R Markdown document from scratch

In this session, we'll look at working with text strings

### R Packages

A very convenient package for working with text in R is called `stringr`, however, many of you may not know what a package is.
Put simply, a package is a collection of functions that can be used together to perform similar or related tasks.

When you open an initial R session, a handful of packages are loaded by default, such as `r pander::pander(.packages())`.
Each of these packages has a set of related functions.
For example, `sd()`, `var()`, `cor()` and `rnorm()` all live in the `stats` package as they are about distributional parameters or statistical model-fitting.
Alternatively, `abs()`, `max()`, `log()` and other functions live in `base` are they are the fundamental functions required for performing any calculations.
If you go to the help page for any of these, you'll see the package name at the top left of each help page in the curly braces.

There are thousands of packages available, and loading them all every time we start `R` would take hours, so for each analysis, we just need to load the packages that are relevant to each analysis.
For this section, we're going to manipulate text and the package we'll look at is `stringr`.


## Working with Text 

### Start a new R Markdown Document

Making sure you're in the appropriate R Project, create a new R Markdown file called `TextManipulation.Rmd`.
Throughout this section, please write copious notes to yourself about what we are doing.
We will note give you exact guidance on this, but remember that you are creating a reference document for yourself so you can find your way around later.
Take the time to write everything in a way that you find clear.
It's better to go slowly and understand everything, than to finish but to have no idea what you've done.

Once you've got your new R Markdown document, make sure you're happy with the YAML header, then delete everything after the first chunk (`setup`).
**Compile just to check you haven't broken anything.**

A good tip is to load all packages you need for a workflow at the beginning. 
This helps identify any potential conflicts between packages early, as sometimes two packages don't play well together, and may even have identically named functions.

Start a new chunk and set the label to be `load_packages` or something similar.
Inside that chunk add the code 

```{r}
library(stringr)
```

This will load the package `stringr`, which has a raft of functions for manipulating text.
Often we'll need to know these tricks as our sample names may have multiple genotypes or treatment embedded in them, and knowing how to get these pieces of information out can be very helpful.
Other times, we need to know how to correct typos longs the lines of sex being recorded as `male`, `female`, `M`, `m`, `f` or `F` all in the same document.
This type of thing happens more than you may realise, especially when dealing with large datasets that have a lot of manually entered values.

The first thing we'll need to do is create a character vector that we'll work with for this section.
Create new chunk called `hi` and create the vector `hi` as follows.

```{r hi}
hi <- c("Hi Mum", "Hi Mother")
```

This is a simple character vector (of length `r length(hi)`) with two closely related phrases.

The package `stringr` has a whole series of functions, many of which start with `str_`.
From here on, we strongly advise to demonstrate each function within it's own chunk, and for you to make notes in your R Markdown document that help you understand what we're doing.
For most of the following examples, we won't actually create a new object, but will just demonstrate the output of each function.
Importantly, for most of the functions we look at, we pass them a character vector of length `r length(hi)`, and we will return a character vector of length `r length(hi)`.
There are a few exceptions though.

### Changing Case

We can very easily change the case of our vector, and this may be of help when our collaborators have given us same strange combination of M/m/F/f encoding for the sex of our samples.
The main functions are `str_to_lower()`, `str_to_upper()` and `str_to_title`, with final helpful function being `str_to_sentence()`.

```{r}
str_to_lower(hi)
str_to_upper(hi)
str_to_title(hi)
str_to_sentence(hi)
```

Make sure you describe what each function does.

### Removing Unwanted Text

Often we have to remove unwanted text, like file suffixes and directory names, and `str_remove_all()` makes this easy.
There are two arguments we need to provide to this function.
The first is called `string`, whilst the second argument is called `pattern`.
We didn't worry about this for the first group of functions, as we really just needed to pass our character vector to the function.
Now, we need to specify two arguments.

```{r}
str_remove_all(string = hi, pattern = "M")
```

#### A Note On Calling Functions in R

When we call a function in R, we can pass what we need to each argument, by naming the argument explicitly like we did above.
The string we're going to search is provided in the vector `hi`, whilst the pattern we're looking to remove is the character "M".

If we don't wish to name them explicitly, we can pass them in the order specified by the help page.
The following two commands are identical.

```{r}
str_remove_all(string = hi, pattern = "M")
str_remove_all(hi, "M")
```

As you learn, there may be times when you specifically name each argument, whilst this may not be required at other times.
For most of the following code, we won't name the arguments as we'll almost always be providing a string (`hi`) and a pattern that we're matching.

#### Back To Editing Our Text

Returning back to `str_remove_all()`.
As well as specifying exact patterns to match, we can set alternatives.
In the following, we'll remove either an upper or lower case `m` by providing a set of alternative characters within the square brackets.
To demonstrate a larger set of characters, we'll follow that by removing all lower case vowels. 

```{r}
str_remove_all(hi, "[Mm]")
str_remove_all(hi, "[aeiou]")
```

There is an alternative function `str_remove()` provided by `stringr` which will only remove the first match to the supplied pattern.
This is mostly not the function you'll be after, but you may choose it by accident at some point, then wonder what went wrong.

In `stringr` syntax (which is based on regular expressions), we can also set a wild-card character by using the `.` symbol.
For those familiar with regular expressions, this will be old news, but for those who are not familiar with `regexp` syntax this may be a new way of working with text.
Some of you may also be familiar with using the `*` symbol as a plain-text wild-card, but importantly the `*` symbol doesn't work in that manner here.

```{r}
str_remove_all(hi, "Mu")
str_remove_all(hi, "M.")
```

In this last example, we've removed the upper case `M` and any single character that follows.
We could remove any number of following characters by adding a `+` symbol after the `.`, which is interpreted as *match anything (.) one or more times (+)*

```{r}
str_remove_all(hi, "M.+")
```

### Extracting Patterns

As well as just removing sections of a text string,there are various methods for reaching into a text string and grabbing the patterns we need.
The first of these is `str_extract()`
If we search for a pattern that doesn't exist, `str_extract()` will return a missing value (`NA`).

```{r}
str_extract(hi, "Mu")
str_extract(hi, "M.+")
```

Notice how the patterns behave in the exact same manner as we saw with `str_replace_all()`.
We can also use exact positions within a text string using `str_sub()`, however, notice that naming the arguments explicitly is really helpful here.

```{r}
str_sub(hi, start = 4, end = 5)
```

### Replacing Text

Sometimes, we don't need to just find or extract pattern, but we need to perform more complex manipulations.
The function `str_replace()` allows us to specify the arguments `string` & `pattern` as we've already seen, but also the third argument `replacement`.
Once again, the following two commands are identical, because we are providing the arguments in order.

```{r}
str_replace(string = hi, pattern = "Hi", replacement = "Hello")
str_replace(hi, "Hi", "Hello")
```

We can also use our pattern matching tricks to replace either "Mum" or "Mother" with "Dad"

```{r}
str_replace(hi, "M.+", "Dad")
```

`str_replace()` also allows us to 'capture' a pattern and incorporate it in the replacement.
To capture a pattern, we surround it in the round braces `()`.
To return the pattern, we use the shortcut `\\1` which will return the first pattern we have captured.
In the following, notice that we're matching white-space followed by "(M.+)", where the captured pattern is "M.+".
In the replacement, we're replacing the entire pattern with a long string, but this string include the captured pattern.

```{r}
str_replace(hi, " (M.+)", "! We captured and replaced the pattern \\1.")
```

We can capture multiple patterns, and return them in any order we choose.
In the following, our first capture will be "Hi", then we won't capture the white-space, but we then capture the pattern "M.+" as before.
In our replacement, we're returning them in the opposite order that we captured them in, and we're also including some exclamation marks and additional white-space.

```{r}
str_replace(hi, "(Hi) (M.+)", "\\2! \\1!")
```

Just like `str_remove()` and `str_remove_all()`, there are two versions of `str_replace()`.
The first will only replace the first match to the pattern, whilst `str_replace_all()` will replace all matches to the pattern.

```{r}
str_replace(hi, "[Mm]", "b")
str_replace_all(hi, "[Mm]", "b")
```

### A few more handy functions

If we wish to ensure that our text strings are all the same length, we can pad them with any character we choose.
In the first example, we're setting our new strings to be 10 characters wide, and we're padding on the right with exclamation marks.
Note again, that explicitly naming the arguments here helps us understand exactly what we're doing with the function.

```{r}
str_pad(hi, width = 10, side = "right", pad = "!")
```

A far more common use for something like this would be to pad numbers to ensure we have the same number of digits.
Once that numbers are represented as characters, most sort algorithms sort them alpha-numerically instead of numerically.
We often see strange ordering like `r pander::pander(sort(as.character(1:10)))` instead of the more reasonable `r pander::pander(1:10)`.
In the next line, we'll add zeroes in front of the numbers to ensure every number has two digits.
Once we've done this, alpha-numeric sorting and numeric sorting will give the same results.

```{r}
str_pad(1:10, width = 2, pad = "0")
```

Sometimes we end up with ridiculously long text strings, so we can use `str_trunc()` to truncate these. 
By default, the last 3 characters of a truncated string will be given as the ellipsis (`...`) to indicate the text has been shortened.

```{r}
str_trunc(hi, width = 6)
```

Finally, we often see text strings which have white-space in weird places, so we can remove this using `str_trim()`.
This will remove white-spaces from the start or end.

```{r}
str_trim("   Hi!")
```


## Approaches that Return Different Structures

In all of the above, we provided a character vector of length `r length(hi)` and we obtained a character vector of length `r length(hi)` as our output.
(`NA` technically still counts as a character)

There are multiple other functions which exist that return output in different forms

#### Finding Matching Text

```{r}
str_detect(hi, "Mum")
str_subset(hi, "Mum")
str_subset(hi, "M.")
str_ends(hi, "m")
str_starts(hi,"Hi")
str_locate(hi, "M.+")
str_view_all(hi, "M.+")
```

#### Counting letters

```{r}
str_length(hi)
str_count(hi, "[Hh]")
str_count(hi, "[HMhm]")
```

```{r}
str_flatten(hi, collapse = ", ")
```

```{r}
str_split(hi, " ")
str_split_fixed(hi, " M", 2)
```

